#pragma once
#ifndef _HANDLE_DRAW_H_
#define _HANDLE_DRAW_H_

#include "HandleEvent.h"
#include <commdlg.h>

//In drag mode type
#define DRAG_SELECTALL FALSE	//For drag normally after selecting: select all figure in rcSelect
#define DRAG_SELECTLAST TRUE	//For drag after drawing: select only the drawn figure

class HandleDraw {

private:	//private attribute

	//Color while drawing
	static CHOOSECOLOR  _cc;
	static COLORREF  _acrCustClr[16];
	static DWORD  _color;
	static HBRUSH  _hbrush;

	//shapes which are being dragged
	static std::vector<Shape> _draggedShapes;
private:	//private helper method

	//Helper for onPaint
	// Get a ptr to a figure which was generated by fromX, fromY, toX, toY
	static std::shared_ptr<figure::Figure> getFigureToDraw(int typeFigure, int fromX, int fromY, int toX, int toY) {

		if (TYPE_ELLIPSE == typeFigure) return std::make_shared<figure::Ellipse>
			(figure::Point(fromX, fromY), figure::Point(toX, toY));
		if (TYPE_RECTANGLE == typeFigure) return std::make_shared <figure::Rectangle>
			(figure::Point(fromX, fromY), figure::Point(toX, toY));
		if (TYPE_LINE == typeFigure) return	std::make_shared<figure::Line>
			(figure::Point(fromX, fromY), figure::Point(toX, toY));

		//Init for circle or square
		int dx = toX - fromX;
		int dy = abs(dx);
		if (toY - fromY < 0) dy *= -1;


		if (TYPE_CIRCLE == typeFigure) {
			return	std::make_shared<figure::Circle>
				(figure::Point(fromX, fromY), figure::Point(fromX + dx, fromY + dy));
		}

		if (TYPE_SQUARE == typeFigure) {
			return	std::make_shared<figure::Square>
				(figure::Point(fromX, fromY), figure::Point(fromX + dx, fromY + dy));
		}

		return nullptr;
	};

	static void initToDraw(HDC& hdc, HDC& memDC, HBITMAP& memBMP) {
		//Create a memoryDC as a temp DC:
		//We will paint everything into memoryDC and copy data from memoryDC -> DC
		//	This will make you do not erase figures which are in DC 
		//	when you are in Preview mode
		memDC = CreateCompatibleDC(hdc);
		memBMP = CreateCompatibleBitmap(hdc,
			rcHWND.right - rcHWND.left,
			rcHWND.bottom - rcHWND.top);
		SelectObject(memDC, memBMP);
		FillRect(memDC, &rcHWND, (HBRUSH)(COLOR_WINDOW + 1));

		//this would make draw transparent figure
		SelectObject(memDC, GetStockObject(NULL_BRUSH));
	}

	static void drawIntoMemDC(HDC& memDC, Pen& pen, int type = typeFigure,
		int left = fromX, int top = fromY, int right = toX, int bottom = toY) {

		std::shared_ptr<figure::Figure> figure =
			getFigureToDraw(type, left, top, right, bottom);

		//Set the figure to draw
		pen.setFigure(figure);

		//Draw the figure
		pen.draw(memDC);
	}

	static void modePreview(HDC& hdc, HDC& memDC) {
		if (MODE_PREVIEW != mode) return;

		
		Pen::drawAll(memDC);
		Pen pen(memDC, PS_DASHDOT, 3, _color);
		drawIntoMemDC(memDC, pen);

		//Copy data from memoryDC -> hdc
		BitBlt(hdc, 0, 0,
			rcHWND.right - rcHWND.left,
			rcHWND.bottom - rcHWND.top,
			memDC, 0, 0, SRCCOPY);
	}

	static void modeDraw(HDC& hdc, HDC& memDC) {
		if (MODE_DRAW != mode) return;

		Pen::drawAll(memDC);
		Pen pen(memDC, PS_DASHDOT, 3, _color);
		drawIntoMemDC(memDC, pen);

		//Save true shape
		pen.saveShape();

		
		//Deactivated draw mode
		//mode = MODE_NULL;

		//Copy data from memoryDC -> hdc
		BitBlt(hdc, 0, 0,
			rcHWND.right - rcHWND.left,
			rcHWND.bottom - rcHWND.top,
			memDC, 0, 0, SRCCOPY);
	}

	static void modeSelect(HDC& hdc, HDC& memDC) {
		if (MODE_SELECT != mode) return;

		Pen pen(memDC);
		Pen::drawAll(memDC);

		//Set style to draw rcSelect
		pen.setStyle(memDC, PS_DASHDOT, 1, RGB(0, 0, 255));

		//Draw preview of rcSelect
		drawIntoMemDC(memDC, pen);

		//Copy data from memoryDC -> hdc
		BitBlt(hdc, 0, 0,
			rcHWND.right - rcHWND.left,
			rcHWND.bottom - rcHWND.top,
			memDC, 0, 0, SRCCOPY);
	}

	static void modeDrag(HDC& hdc, HDC& memDC, bool isDragAfterDrawType) {
		if (MODE_DRAG != mode) return;

		Pen pen(memDC);			//Pen to draw rcSelected
		Pen::drawAll(memDC);

		//If there is no seleted shape before
		if (_draggedShapes.empty()) {
			//Find the shapes which are in rcSelect
			for (int i = states.size() - 1; i >= 0; --i) {

				if (states[i].isValid && states[i].figure->isIn(rcSelectOriginal)) {

					//Save the shape to drag
					_draggedShapes.push_back(states[i]);
					//_draggedShapes.back().color = _color;
					_draggedShapes.back().executedFrom = &states[i];
					_draggedShapes.back().figure = states[i].figure->duplicate();

					//invalidate the selected shape (which mean this cannot be drawn)
					// We do not delete the old seletected shape because of undoing/redoing
					states[i].isValid = false;
					if (isDragAfterDrawType) break;	//Get only the last figure when in this mode
				}
			}
		}

		//Drag rcSelect
		pen.setStyle(memDC, PS_DASHDOT, 1, RGB(0, 0, 255));
		drawIntoMemDC(memDC, pen, TYPE_RECTANGLE,
			rcSelect.left, rcSelect.top, rcSelect.right, rcSelect.bottom);


		//Drag the selected figure
		if (!_draggedShapes.empty()) {
			for (Shape i : _draggedShapes) i.figure->move(figure::Point(dx, dy));
			Pen::drawAll(memDC, _draggedShapes);
		}

		
		//Copy data from memoryDC -> hdc
		BitBlt(hdc, 0, 0,
			rcHWND.right - rcHWND.left,
			rcHWND.bottom - rcHWND.top,
			memDC, 0, 0, SRCCOPY);
	}

public:


	//After dragging, if there are some selected shape
	//	=> push back into states and clear all current selected shapes
	static void finishToDrag(std::vector<Shape>& states) {
		if (!_draggedShapes.empty()) {
			for (Shape i : _draggedShapes) {
				states.push_back(i);
			}
			_draggedShapes.clear();
		}
	}

	//Choose color from menu
	static void getColor(HWND& hwnd) {
		ZeroMemory(&_cc, sizeof(CHOOSECOLOR));
		_cc.lStructSize = sizeof(CHOOSECOLOR);
		_cc.hwndOwner = hwnd;
		_cc.lpCustColors = (LPDWORD)_acrCustClr;
		_cc.rgbResult = _color;
		_cc.Flags = CC_FULLOPEN | CC_RGBINIT;
		if (ChooseColor(&_cc))
		{
			_hbrush = CreateSolidBrush(_cc.rgbResult);
			_color = _cc.rgbResult;
		}
	}

	static void draw(HWND& hwnd) {

		//Setup draw space
		GetClientRect(hwnd, &rcHWND);

		//Prevent every time we use FillRect(), we do not erase the toolbar
		rcHWND.top += IMAGE_HEIGHT + 10;

		//Begin pain :<<
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hwnd, &ps);
		HDC memoryDC;
		HBITMAP memoryBMP;

		//Init variables
		initToDraw(hdc, memoryDC, memoryBMP);
		
		//Mode decision
		if (MODE_PREVIEW == mode) modePreview(hdc, memoryDC);
		else if (MODE_DRAW == mode) modeDraw(hdc, memoryDC);
		else if (MODE_SELECT == mode) modeSelect(hdc, memoryDC);
		else if (MODE_DRAG == mode) modeDrag(hdc, memoryDC, isDragAfterDraw);
		
		//End pain :<<<
		DeleteObject(hdc);
		DeleteObject(memoryBMP);
		DeleteDC(memoryDC);
		EndPaint(hwnd, &ps);
		
	}
};

std::vector<Shape> HandleDraw::_draggedShapes;

CHOOSECOLOR  HandleDraw::_cc;
COLORREF  HandleDraw::_acrCustClr[16];
DWORD HandleDraw::_color = RGB(255, 0, 0);
HBRUSH  HandleDraw::_hbrush;

#endif // !_HANDLE_DRAW_H_




